package model;

/**
 * A GraphClass describes the class a {@link Graph} belongs to. It also provides
 * methods to get a graph, if parameters are set, from the
 * {@link GraphGenerator} for its type, and to get the number of pages needed
 * and minimal number of crossings possible for given number of pages and
 * vertices, if known.
 * 
 * @author Jonathan Klawitter, Matthias Wolf, Michael Wegner
 * @see Graph
 * @see GraphGenerator
 */
public enum GraphClass {

	EDGELESS, PATH, CYCLE, STAR,
	/** A full binary tree generated by height. */
	FULL_BINARY_TREE(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		public Graph getMyGraph(int height) {
			return GraphGenerator.fullBinaryTreeByHeight(height);
		}

		@Override
		public int getPageNumber(int n) {
			return 1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			if (k >= 1) {
				return 0;
			} else {
				return -1;
			}
		}
	},
	/** A random tree based on a randomly generated PrÃ¼fer sequence. */
	RANDOM_TREE(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.randomTreePrueferSequence(numberOfVertices, this.getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return 1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return 0;
		}
	},
	/** A random tree based on iteratively and randomly adding children. */
	RANDOM_TREE_CHILDBASED(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.randomTree(numberOfVertices, this.getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return 1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return 0;
		}
	},
	/** A random tree based on an initial path. */
	RANDOM_TREE_PATHBASED(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.randomTree2(numberOfVertices, this.getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return 1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return 0;
		}
	},
	CACTUS(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		public Graph getMyGraph(int numberOfVertices) {
			int k = numberOfVertices / 10;
			return GraphGenerator.cactus(numberOfVertices, k, getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return 1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return 0;
		}
	},
	MAX_OUTERPLANAR(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.maxOuterplanarGraph(numberOfVertices, this.getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return 1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return 0;
		}

	},
	OUTERPLANAR(GraphGenerator.NEED_PROB, GraphGenerator.NEED_SEED) {
		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.outerplanarGraph(numberOfVertices, this.getSeed(),
					this.getProbability());
		}

		@Override
		public int getPageNumber(int n) {
			return 1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return 0;
		}
	},
	HAMILTONIAN_MAX_PLANAR(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		@Override
		public Graph getMyGraph(int n) {
			return GraphGenerator.hamiltonianMaxPlanarGraph(n, getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return 2;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			if (k >= 2) {
				return 0;
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	HAMILTONIAN_MAX_PLANAR_UNSHUFFLED(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		@Override
		public Graph getMyGraph(int n) {
			return GraphGenerator.unshuffledHamiltonianMaxPlanarGraph(n, getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return 2;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			if (k >= 2) {
				return 0;
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	SUBHAMILTONIAN_PLANAR(GraphGenerator.NEED_PROB, GraphGenerator.NEED_SEED) {
		@Override
		public Graph getMyGraph(int n) {
			return GraphGenerator.subhamiltonianPlanarGraph(n, getSeed(), getProbability());
		}

		@Override
		public int getPageNumber(int n) {
			return 2;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			if (k >= 2) {
				return 0;
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	SUBHAMILTONIAN_PLANAR_UNSHUFFLED(GraphGenerator.NEED_PROB, GraphGenerator.NEED_SEED) {
		@Override
		public Graph getMyGraph(int n) {
			return GraphGenerator.unshuffledSubhamiltonianPlanarGraph(n, getSeed(),
					getProbability());
		}

		@Override
		public int getPageNumber(int n) {
			return 2;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			if (k >= 2) {
				return 0;
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	RANDOM(GraphGenerator.NEED_PROB, GraphGenerator.NEED_SEED) {
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.randomGraph(numberOfVertices, this.getProbability(),
					this.getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		public int getMinCrossings(int k, int n) {
			return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}
	},
	DENSITY(GraphGenerator.NEED_PROB, GraphGenerator.NEED_SEED) {

		@Override
		public Graph getMyGraph(int n) {
			return RandomGraphGenerator.getRandomGraph(n, this.getDensity(), this.getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}

	},
	MAX_PLANAR(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.maximalPlanarGraph(numberOfVertices, this.getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return 3;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			if (k >= 3) {
				return 0;
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	ONE_PLANAR(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.maximal1PlanarGraph(numberOfVertices, this.getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			if (k >= 16) {
				return 0;
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	RANDOM_PLANAR_PROBABILIYTY(GraphGenerator.NEED_PROB, GraphGenerator.NEED_SEED) {
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.randomPlanarGraph(numberOfVertices, this.getProbability(),
					this.getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return MAX_PLANAR.getPageNumber(n);
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return MAX_PLANAR.getMinCrossings(k, n);
		}
	},
	HYPERCUBE(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		public Graph getMyGraph(int dimension) {
			return GraphGenerator.hyperCube(dimension);
		}

		@Override
		public int getPageNumber(int dimension) {
			// DOI: 10.1002/scj.4690200404
			return Math.max(1, dimension - 1);
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return (k >= this.getPageNumber(n)) ? 0 : Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}
	},
	GRID(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.grid(numberOfVertices, numberOfVertices);
		}

		@Override
		public int getPageNumber(int n) {
			return 2;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return (k >= this.getPageNumber(n)) ? 0 : Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}
	},
	TORUS(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		@Override
		public Graph getMyGraph(int width) {
			if (width > 0) {
				return GraphGenerator.torus(width);
			} else {
				if (this.getSeed() == 0) {
					return GraphGenerator.torus(getSteps()[0], getSteps()[1]);
				} else {
					return GraphGenerator.torusShuffled(getSteps()[0], getSteps()[1]);
				}
			}
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}
	},
	K_ARY_N_CUBE(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		@Override
		public Graph getMyGraph(int dimension) {
			return GraphGenerator.kAryNCube(dimension, getParameterK());
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}
	},
	/** A complete graph K_n */
	COMPLETE(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.completeGraph(numberOfVertices);
		}

		@Override
		public int getPageNumber(int n) {
			return (int) Math.ceil(((double) n) / 2.0);
		}

		@Override
		public int getMinCrossings(int k, int n) {
			if (k >= this.getPageNumber(n)) {
				return -1;
			} else if (k == 2) {
				return functionZ(n);
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	/** A complete bipartite graph K_n,n */
	COMPLETE_BIPARTITE_BALANCED(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		/**
		 * 
		 * @param numberOfVertices
		 *            - equals sum (n+n) for K_n,n, has to be even
		 */
		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.completeBalancedBipartiteGraph(numberOfVertices);
		}

		@Override
		public int getPageNumber(int numberOfVertices) {
			if (numberOfVertices % 2 == 1) {
				numberOfVertices--;
			}
			return (int) Math.ceil(numberOfVertices / 3) + 1;
			// Enomoto: doi:10.1006/jctb.1997.1773
		}

		@Override
		public int getMinCrossings(int k, int numberOfVertices) {
			if (numberOfVertices % 2 == 1) {
				throw new IllegalArgumentException();
			}
			if (k >= this.getPageNumber(numberOfVertices)) {
				return 0;
			} else if (k == 2) {
				return functionZ(numberOfVertices / 2, numberOfVertices / 2);
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	/** A complete bipartite graph K_m,n with m = n(n-1) + 1 */
	COMPLETE_BIPARTITE_UNBALANCED(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.completeUnbalancedBipartiteGraph(numberOfVertices);
		}

		/**
		 * Returns the page number for given n of K_m,n with m = n(n-1) + 1
		 * 
		 * @param n
		 *            - n of K_m,n with m = n(n-1) + 1
		 * @return the page number
		 */
		@Override
		public int getPageNumber(int numberOfVertices) {
			int[] nm = getNAndMOfUnbalancedCompleteBipartiteGraph(numberOfVertices);
			return nm[0];
		}

		/**
		 * Returns the (conjectured) minimal number of crossings for given
		 * n[0]=n, n[1]=m of K_m,n with m = n(n-1) + 1 and k.
		 * 
		 * @param k
		 *            - number of pages
		 * @param n
		 *            - n[0]=n and n[1]=m of K_m,n with m = n(n-1) + 1
		 * @return the page number
		 */
		@Override
		public int getMinCrossings(int k, int numberOfVertices) {
			int[] nm = getNAndMOfUnbalancedCompleteBipartiteGraph(numberOfVertices);
			if (k >= this.getPageNumber(numberOfVertices)) {
				return 0;
			} else if (k == 2) {
				return functionZ(nm[0], nm[1]);
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	COMPLETE_BIPARTITE_1OFF(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		/**
		 * @param numberOfVertices
		 *            - has to be odd
		 * @returns K_i,i-1 with i+i-1=numberOfVertices
		 */
		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.completeBipartiteGraph1Off(numberOfVertices);
		}

		/**
		 * Returns the page number for given n of K_m,n with m = n(n-1) + 1
		 * 
		 * @param n
		 *            - n of K_m,n with m = n(n-1) + 1
		 * @return the page number
		 */
		@Override
		public int getPageNumber(int numberOfVertices) {
			return -1;
		}

		/**
		 * Returns the (conjectured) minimal number of crossings for given
		 * n[0]=n, n[1]=m of K_m,n with m = n(n-1) + 1 and k.
		 * 
		 * @param k
		 *            - number of pages
		 * @param n
		 *            - n[0]=n and n[1]=m of K_m,n with m = n(n-1) + 1
		 * @return the page number
		 */
		@Override
		public int getMinCrossings(int k, int numberOfVertices) {
			if (k >= numberOfVertices / 2) {
				return 0;
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	COMPLETE_TRIPARTITE(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {

		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.completeTripartiteGraph(numberOfVertices, numberOfVertices,
					numberOfVertices);
		}

		@Override
		public int getPageNumber(int n) {

			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}

	},
	CIRCULANT(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.circulantGraph(numberOfVertices, this.getSteps());
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}
	},
	ALMOST_TREE(GraphGenerator.NEED_PROB, GraphGenerator.NEED_SEED) {
		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.almostTree(numberOfVertices, this.getProbability(),
					this.getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}

	},
	UNDEFINED(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return null;
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}
	},
	ROME(GraphGenerator.NO_PROB, GraphGenerator.NO_SEED) {
		@Override
		public Graph getMyGraph(int romeGraphNumber) {
			return GraphMLIO.getRomeGraph(romeGraphNumber, GraphMLIO.SRCDIR_ROME);
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}
	},
	RANDOM_PLANAR_EDGE_DISTRIBUTABLE(GraphGenerator.NEED_PROB, GraphGenerator.NEED_SEED) {
		private final int targetNumPages = 4;

		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.randomPlanarEdgeDistributableGraph(numberOfVertices,
					getProbability(), targetNumPages, getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			if (k >= targetNumPages) {
				return 0;
			} else {
				return -1;
			}
		}
	},
	RANDOM_JUST_NOT_PLANAR_EDGE_DISTRIBUTABLE(GraphGenerator.NEED_PROB, GraphGenerator.NEED_SEED) {
		private final int targetNumPages = 4;

		@Override
		public Graph getMyGraph(int numberOfVertices) {
			return GraphGenerator.randomJustNotPlanarEdgeDistributableGraph(numberOfVertices,
					getProbability(), targetNumPages, getSeed());
		}

		@Override
		public int getPageNumber(int n) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return -1;
		}
	},
	K_TREE(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		@Override
		public Graph getMyGraph(int n) {
			return GraphGenerator.kTree(n, getParameterK(), getSeed());
		}

		@Override
		public int getPageNumber(int k) {
			return k + 1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			if (k >= getPageNumber(k)) {
				return 0;
			} else {
				return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
			}
		}
	},
	PERMUTATION(GraphGenerator.NO_PROB, GraphGenerator.NEED_SEED) {
		@Override
		public Graph getMyGraph(int n) {
			return GraphGenerator.permutationGraph(n, getSeed());
		}

		@Override
		public int getPageNumber(int k) {
			return -1;
		}

		@Override
		public int getMinCrossings(int k, int n) {
			return Problem.UNKNOWN_NUMBER_OF_CROSSINGS;
		}
	};

	/** Seed used in randomized parts of graph generation. */
	private int seed = 1;
	/** Probability of edges taken in generated graph. */
	private double probability;

	/** k used in k-trees and k-ary n-cubes. */
	private int parameterK = 3;

	/** density used in random graphs. */
	private RandomGraphGenerator.EdgeDensity density = null;

	/** Steps used in circulant graphs. */
	private int[] steps = new int[] { 1 };

	/** Whether getting a graph needs a set probability. */
	private final boolean needsProbability;
	/** Whether getting a graph needs a set seed. */
	private final boolean needsSeed;

	private GraphClass(boolean needsProbability, boolean needsSeed) {
		this.needsProbability = needsProbability;
		this.needsSeed = needsSeed;
	}

	/**
	 * @return whether a probability is needed for graph generation
	 */
	public boolean needsProbability() {
		return needsProbability;
	}

	public double getProbability() {
		return probability;
	}

	public void setProbability(double probability) {
		this.probability = probability;
	}

	/**
	 * @return whether seed is needed for graph generation
	 */
	public boolean needsSeed() {
		return needsSeed;
	}

	public int getSeed() {
		return seed;
	}

	public GraphClass setSeed(int newSeed) {
		this.seed = newSeed;
		return this;
	}

	/**
	 * @return the k
	 */
	public int getParameterK() {
		return parameterK;
	}

	/**
	 * @param k
	 *            the k to set
	 */
	public void setParameterK(int k) {
		this.parameterK = k;
	}

	/**
	 * @return the density
	 */
	public RandomGraphGenerator.EdgeDensity getDensity() {
		return density;
	}

	/**
	 * @param density
	 *            the density to set
	 */
	public void setDensity(RandomGraphGenerator.EdgeDensity density) {
		this.density = density;
	}

	public int[] getSteps() {
		return steps;
	}

	public GraphClass setSteps(int[] steps) {
		this.steps = steps;
		return this;
	}

	public abstract Graph getMyGraph(int n);

	/**
	 * Returns the page number of this graph type by given n or -1 if unknown.
	 * 
	 * @param n
	 *            - number of vertices
	 * @return the page number of this graph type by given n or -1 if unknown
	 */
	public abstract int getPageNumber(int n);

	/**
	 * Returns the minimal number of crossings for given n and k and this graph
	 * type or -1 if unknown.
	 * 
	 * @param k
	 *            - number of pages
	 * @param n
	 *            - number of vertices
	 * @return the minimal number of crossings for given n and k or -1 if
	 *         unknown
	 */
	public abstract int getMinCrossings(int k, int n);

	public static int[] getNAndMOfUnbalancedCompleteBipartiteGraph(int numberOfVertices) {
		int[] nm = new int[2];
		nm[0] = (int) (Math.sqrt(4 * numberOfVertices - 4) / 2);
		nm[1] = numberOfVertices - nm[0];
		return nm;
	}

	private static int functionZ(int n, int m) {
		return functionX(n) * functionX(m);
	}

	private static int functionZ(int n) {
		return functionX(n) * functionX(n - 2) / 4;
	}

	private static int functionX(int n) {
		return (int) (Math.floor(n / 2) * Math.floor((n - 1) / 2));
	}

	// public static int getHyperCubeDimensionByN(int n) {
	// // iff 2^(s-1) < n <= 2^s
	// int oldPowertOfTwo = 0;
	// int powerOfTwo = 1;
	// for (int i = 0; i < 32; i++) {
	// if ((oldPowertOfTwo < n) && (n <= powerOfTwo)) {
	// return i;
	// }
	// oldPowertOfTwo = powerOfTwo;
	// powerOfTwo *= 2;
	// }
	// return -1;
	// }
}
