# GraphGenerators
Collection of generators for various different graph classes.

## Graph classes
The list below contains all graph classes supported so far. All graphs are simple, which means they have no loops or multi-edges. The parameter *n* stands for number of vertices, *m* for number of edges, *d* for dimension, *p* for a probability, *g/g1/g2* for a graph, *s* for a seed.

- `edgelessGraph(n)`, the [edgeless graph](https://en.wikipedia.org/wiki/Null_graph#Edgeless_graph) *\bar{K_n}*, also called empty graph, or null graph
- `path(n)`, the [path graph](https://en.wikipedia.org/wiki/Path_graph) *P_n*
- `cycle(n)`, the [cycle](https://en.wikipedia.org/wiki/Cycle_graph) *C_n* (not to confuse with a [circle graph](https://en.wikipedia.org/wiki/Circle_graph))
- `prueferTree(n)`, a (unlabelled) tree based on a random [Prüfer sequence](https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence)
- `star(n)`, a [star graph](https://en.wikipedia.org/wiki/Star_(graph_theory)) *S_n* with *n-1* leaves
- `createMaxOuterplanarGraph(n, s)`, a random [maximal outerplanar graph](https://en.wikipedia.org/wiki/Outerplanar_graph)
- `createApollonianNetwork(n, s)`, a random [Apollonian network](https://en.wikipedia.org/wiki/Apollonian_network)
- `createMaxPlanarGraph(n, flips, s)`, a random maximal [planar graph](https://en.wikipedia.org/wiki/Planar_graph) generated by starting with a random [Apollonian network](https://en.wikipedia.org/wiki/Apollonian_network) and then doing `steps` many random edge flips (recommended to use at least *n^3* many flips)
- `createHamiltonianMaxPlanarGraph(n, s)`, a random maximal [planar graph](https://en.wikipedia.org/wiki/Planar_graph) that is Hamiltonian, i.e. contains a [Hamiltonian cycle](https://en.wikipedia.org/wiki/Hamiltonian_path), based on the merging two maximal outerplanar graphs
- `createMaxOnePlanarGraph(n, flips, s)`, creates a random [1-planar graph](https://en.wikipedia.org/wiki/1-planar_graph) by adding edges to quadrangles of a first created maximal planar graph
- `kPlanar(n, k, s)`, a [*k*-planar graph](https://en.wikipedia.org/wiki/1-planar_graph) generated from a random point set that is swept from left to right and edges added if they do not introduce more than $k$ crossings
- `kTree(n, k, s)`, a [*k*-tree](https://en.wikipedia.org/wiki/K-tree) (generated as defined recursively, i.e. adding vertex and connecting it to random *k*-clique)
- `hypercube(d)`, the [hypercube](https://en.wikipedia.org/wiki/Hypercube) *Q_d*
- `cubeConnectedCycle(d)`, the [cube-connected cycles graph](https://en.wikipedia.org/wiki/Cube-connected_cycles) based on the hypercube *Q_d*
- `kAryNCube(k, n)`, a *k*-ary *n*-cube which is the product of *n* cycles *C_k*
- `squareGrid(n1, n2)`, a [square grid](https://en.wikipedia.org/wiki/Lattice_graph) of size *n1* times *n2*, i.e. the product of *P_n1* and *P_n2*
- `toroidalGrid(n1, n2)`, the product of the cycles *C_n1* and *C_n2*
- `circulant(n, int[] ... steps)`, a [circulant graph](https://en.wikipedia.org/wiki/Circulant_graph) with given steps, e.g. by the array {1, 2, 4}
- `permuation(n, s)` or `permutation(int[] perm)`, [permutation graph](https://en.wikipedia.org/wiki/Permutation_graph) for a random or given permutation
- `complete(n)`, the [complete graph](https://en.wikipedia.org/wiki/Complete_graph) *K_n*
- `createTuranGraph(n, r)`, the [Turán graph](https://en.wikipedia.org/wiki/Tur%C3%A1n_graph) *T(n,r)*, for example with *r = 2* (resp. *r = 3*) this can be used to create a complete balanced biparite (resp. tripartite) graph

There are also some operators that can be applied on the graph
- `shuffle(g)`, randomises the order of the vertices in the data structure and the order of the edges in the adjacency lists
- `density(g, p)`, given a graph *g* and edge probability *p* in *[0,1]* using the [model of Gilbert](https://en.wikipedia.org/wiki/Random_graph) (but referred to as Erdös-Rényi model)
- `graphProduct(g1, g2)`, creates the [product of the two graphs](https://en.wikipedia.org/wiki/Graph_product)


